# -*- coding: utf-8 -*-
"""EMG_Proc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AsnqH1sz0c57CN6rkJ8KLeFlu3wijhJ7

Las unidades motoras son el conjunto de una neuronas motora (que transmite la se√±al nerviosa) y todas las fibras musculares que esa neurona controla. Los m√∫sculos est√°n compuestos por unidades motoras de diferentes tama√±os y capacidades, que se reclutan en funci√≥n de la intensidad del esfuerzo muscular.

Cada unidad motora tiene una frecuencia de activaci√≥n preferida o frecuencia de disparo que depende de ciertos factores, como su tama√±o, tipo (lenta o r√°pida) y la naturaleza de la contracci√≥n muscular. Esto tiene que ver con el proceso de reclutamiento de unidades motoras y c√≥mo el sistema nervioso las utiliza durante diferentes niveles de esfuerzo.

Existen dos tipos de unidades motoras principales:

* Unidades motoras de **tipo I** (lentas, de contracci√≥n larga y baja fatiga): Estas unidades motoras se reclutan en situaciones de baja intensidad y esfuerzo prolongado, como cuando realizas una caminata o una actividad de resistencia. Estas unidades tienen una frecuencia de disparo baja y pueden generar frecuencias m√°s bajas en el espectro de la se√±al EMG (alrededor de **5-20 Hz**, por ejemplo).
* Unidades motoras de **tipo II** (r√°pidas, de contracci√≥n explosiva y alta fatiga): Son reclutadas durante esfuerzos m√°s intensos y r√°pidos, como en levantamientos de pesas o sprints. Estas unidades motoras tienden a tener una frecuencia de disparo alta y producen frecuencias m√°s altas en el espectro de la se√±al EMG (**por encima de 50 Hz**).

Cuando se realiza una contracci√≥n muscular, el sistema nervioso recluta primero las unidades motoras m√°s peque√±as y lentas (tipo I), ya que estas requieren menos energ√≠a para activarse. A medida que la contracci√≥n se vuelve m√°s intensa, el sistema nervioso recluta unidades motoras m√°s grandes y m√°s r√°pidas (tipo II), que son capaces de generar m√°s fuerza, pero tambi√©n se fatigan m√°s r√°pido.

El proceso de reclutamiento est√° relacionado con la frecuencia a la que las unidades motoras disparan sus impulsos el√©ctricos. A medida que aumenta la intensidad del esfuerzo, el nervio motriz dispara m√°s frecuentemente las unidades motoras de tipo II, lo que se traduce en un aumento de la frecuencia en la se√±al EMG.

En resumen:
* Ejercicio aer√≥bico prolongado (como correr a ritmo moderado durante 30 minutos):
  *  An√°lisis en el tiempo: Ver√≠as una se√±al con baja amplitud, ya que la intensidad del esfuerzo es relativamente constante.
  * An√°lisis en la frecuencia: Ver√≠as frecuencias bajas o medias (m√°s unidades motoras lentas), indicando que el esfuerzo es de baja a moderada intensidad, reclutando principalmente unidades motoras tipo I (lentas).
* Ejercicio anaer√≥bico de alta intensidad (como hacer sprints o levantar pesas):
  * An√°lisis en el tiempo: Ver√≠as una se√±al con alta amplitud, debido a los picos de fuerza en momentos espec√≠ficos.
  * An√°lisis en la frecuencia: Ver√≠as frecuencias m√°s altas, ya que se reclutan unidades motoras tipo II (r√°pidas), lo que indica que el esfuerzo es explosivo y de alta intensidad.
"""

!git clone https://github.com/crisurdiales/EMG-Signal-Processing-Library

#a√±adir la ruta al sistema para poder acceder al codigo
import sys
sys.path.append('/content/EMG-Signal-Processing-Library/Python')

import signal_utilities as su
import emg
#EMG_filter_basic:
#Rectificaci√≥n: Convierte valores negativos en positivos.
#Filtro de media m√≥vil (Moving Average): Suaviza la se√±al.
#Opci√≥n de filtro de paso bajo (Low Pass Filter) si reference_available=True.

#EMG_filter (hereda de EMG_filter_basic):
#A√±ade filtrado para eliminar ruido de baja frecuencia.
#Normaliza la se√±al considerando valores neutros calculados por PkPk.

import pandas as pd
import matplotlib.pyplot as plt

# Cargar datos desde el CSV
data_path = '/content/EMG-Signal-Processing-Library/Sample Signals/emgvalues_1.csv'
emg_data_1 = pd.read_csv(data_path, header=None).squeeze()  # Convierte el DataFrame en Serie
data_path = '/content/EMG-Signal-Processing-Library/Sample Signals/emgvalues_2.csv'
emg_data_2 = pd.read_csv(data_path, header=None).squeeze()
data_path = '/content/EMG-Signal-Processing-Library/Sample Signals/emgvalues_3.csv'
emg_data_3 = pd.read_csv(data_path, header=None).squeeze()

fs = 1000  # Hz, frecuencia de muestreo del EMG que usamos

"""Par√°metros del filtro a crear:


*   sample_frequency_ frecuencia del EMG en Hz
*   range_ n√∫mero de puntos para calcular la media movil en segundos (entre 0.2 y 0.5)
*   min_EMG_frequency_ m√≠nimo valor de frecuencua por debajo del cual se eliminan las muestras (40 est√° bien)
*  max_EMG_frequency lo mismo, pero para alta frecuencia. 150 est√° bien
* remove_low_frequency Si el sensor ya filtra, pues nada, si no, recomendable. Puede ser HIGH_PASS_FILTER_ON o HIGH_PASS_FILTER_OFF
* reference_available indica si tenemos alguna se√±al de referencia. Puede ser REFERENCE_AVAILABLE or REFERENCE_UNAVAILABLE


"""

# Crear filtro b√°sico con frecuencia de muestreo de 200 Hz y ventana de 0.1 segundos
basic_filter = emg.EMG_filter_basic(sample_frequency=fs, range_=0.1, reference_available=False)
# Crear filtro avanzado con par√°metros personalizados
emg_filter = emg.EMG_filter(sample_frequency=fs, range_=0.5, min_EMG_frequency=25, max_EMG_frequency=300, reference_available=False)

#filtramos la se√±al
# Filtrar la se√±al usando el filtro avanzado
filtered_signal_1 = [emg_filter.filter(value) for value in emg_data_1]
filtered_signal_2 = [emg_filter.filter(value) for value in emg_data_2]
filtered_signal_3 = [emg_filter.filter(value) for value in emg_data_3]

# Configurar el eje temporal
time = [i / fs for i in range(len(emg_data_1))]

# Graficar se√±al original vs filtrada
plt.figure(figsize=(15, 6))
plt.plot(time, emg_data_1, label='Se√±al Original', alpha=0.5)
plt.plot(time, filtered_signal_1, label='Se√±al Filtrada', linewidth=2)
plt.title("Filtrado de Se√±al EMG")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud (mV)")
plt.legend()
plt.grid(True)
plt.show()

"""Ahora que la se√±al est√° filtrada, se pueden escoger las m√©tricas que se deseen para el estudio:

Objetivo->M√©tricas recomendadas

*   **Medir fuerza muscular**->RMS, MAV, ARV
*   **Detectar fatiga**->MNF, MDF, ZC
*   **Analizar rapidez de contracci√≥n**->Pk-Pk, SSC
*   **Control de pr√≥tesis**	->RMS, MAV, ZC
*   **Estudios cl√≠nicos**->Entrop√≠a, MNF, MDF

Principales m√©tricas extra en EMG y su relevancia:

1.   **RMS** (Root Mean Square)
Qu√© es: La ra√≠z cuadrada de la media de las se√±ales al cuadrado.
Por qu√© importa:
Proporciona una medida de la intensidad muscular.
Se correlaciona bien con la fuerza generada durante contracciones isom√©tricas.
üß© √ötil para: Evaluar esfuerzos musculares, comparando niveles de activaci√≥n entre tareas.
2.   **MAV** (Mean Absolute Value)
Qu√© es: Promedio de los valores absolutos de la se√±al EMG.
Por qu√© importa:
Similar al RMS pero m√°s simple computacionalmente.
Refleja la actividad general del m√∫sculo.
üß© √ötil para: Seguimiento de patrones de activaci√≥n durante movimientos din√°micos.
3.   **Pk-Pk** (Peak-to-Peak Amplitude)
Qu√© es: Diferencia entre el pico m√°ximo y m√≠nimo en un intervalo.
Por qu√© importa:
Indica la variabilidad y amplitud de la se√±al.
Ayuda a detectar contracciones repentinas o espasmos.
üß© √ötil para: Estudios de reflejos musculares y respuesta r√°pida a est√≠mulos.
4.   **MNF** (Mean Frequency) y **MDF** (Median Frequency)
Qu√© son:
MNF: Promedio de las frecuencias en el espectro.
MDF: Frecuencia que divide el espectro en dos √°reas iguales.
Por qu√© importan:
Son indicadores clave de fatiga muscular.
Durante la fatiga, estas frecuencias suelen desplazarse hacia valores m√°s bajos.
üß© √ötil para: Monitoreo de la resistencia muscular durante ejercicios prolongados.
5.   **ZC** (Zero Crossing)
Qu√© es: N√∫mero de veces que la se√±al cruza el eje cero.
Por qu√© importa:
Se relaciona con la frecuencia y complejidad de la se√±al.
Puede indicar variaciones en la activaci√≥n motora.
üß© √ötil para: Diferenciar tipos de movimientos o niveles de esfuerzo.
6.   **SSC** (Slope Sign Changes)
Qu√© es: N√∫mero de veces que cambia la pendiente de la se√±al.
Por qu√© importa:
Refleja la din√°mica de la contracci√≥n muscular.
√ötil para detectar movimientos r√°pidos o vibraciones musculares.
üß© √ötil para: An√°lisis de actividades deportivas o tareas de precisi√≥n.
7.   **ARV** (Average Rectified Value)
Qu√© es: Promedio de la se√±al rectificada.
Por qu√© importa:
Similar al MAV, representa la energ√≠a de la se√±al.
üß© √ötil para: Estudios cl√≠nicos donde la simplicidad es clave.
8.   **Entrop√≠a y medidas no lineales**
Qu√© es: C√°lculo de la complejidad y aleatoriedad de la se√±al.
Por qu√© importa:
Permite detectar alteraciones neuromusculares o temblores patol√≥gicos.
üß© √ötil para: Diagn√≥stico m√©dico y control de pr√≥tesis mioel√©ctricas.
"""

import numpy as np
# Funciones para calcular las m√©tricas

# 1. RMS
def calculate_rms(signal):
    return np.sqrt(np.mean(np.square(signal)))

# 2. MAV
def calculate_mav(signal):
    return np.mean(np.abs(signal))

# 3. ARV
def calculate_arv(signal):
    return np.mean(np.abs(signal))

# 4. ZC (Zero Crossing)
def calculate_zc(signal):
    zero_crossings = np.where(np.diff(np.sign(signal)))[0]
    return len(zero_crossings)

# Calcular todas las m√©tricas
rms = calculate_rms(filtered_signal_1)
mav = calculate_mav(filtered_signal_1)
arv = calculate_arv(filtered_signal_1)
zc = calculate_zc(filtered_signal_1)

# Mostrar los resultados
print(f'RMS: {rms}')
print(f'MAV: {mav}')
print(f'ARV: {arv}')
print(f'Zero Crossings: {zc}')

"""* RMS (magnitud de la se√±al EMG; se centra en su energ√≠a) para tareas no fatigosas suele estar entre 1 y 10. 33 sugiere una contracci√≥n fuerte.
* MAV (promedio de magnitud de la se√±al), de nuevo, lo normal en reposo entre 1 y 10. 29 es muy alto (RMS es m√°s preciso, en cualquier caso).
* ARV tiene sentido s√≥lo si vamos a enventanar la se√±al, de hecho el sumatorio va entre i e i+j. Si usamos la se√±al completa, es igual a MAV
*  Zero crossings es lo obvio: cuantas veces corta el eje. En contracciones din√°micas (como cuando se mueve una extremidad o el m√∫sculo cambia su longitud), los Zero Crossings aumentan, ya que el m√∫sculo est√° alternando entre contracci√≥n y relajaci√≥n (o distensi√≥n). A medida que un m√∫sculo se fatiga, puede haber menos alternancia en las contracciones y relajaciones, lo que puede reducir el n√∫mero de cruces por cero, indicando una menor din√°mica muscular. Zero Crossing no necesariamente indica activaci√≥n de un m√∫sculo antagonista; tambi√©n puede ser simplemente el paso de contracci√≥n a relajaci√≥n del mismo m√∫sculo.
"""

# 5. MNF y MDF
def calculate_mnf_mdf(signal, fs):
    # Realizamos la FFT de la se√±al
    n = len(signal)
    freqs = np.fft.fftfreq(n, 1/fs)
    fft_signal = np.fft.fft(signal)

    # Calculamos el espectro de potencia
    power_spectrum = np.abs(fft_signal)**2

    # Filtramos las frecuencias negativas
    # Create a mask for positive frequencies with the original length
    mask = freqs > 0

    # Apply the mask to both frequencies and power spectrum
    freqs = freqs[mask]
    power_spectrum = power_spectrum[mask]

    # Calculamos MNF y MDF
    mnf = np.sum(freqs * power_spectrum) / np.sum(power_spectrum)
    mdf = freqs[np.cumsum(power_spectrum) >= np.sum(power_spectrum) / 2][0]

    return mnf, mdf

# 6. PKF (Peak Frequency)
def calculate_pkf(signal, fs):
    # Realizamos la FFT de la se√±al
    n = len(signal)
    freqs = np.fft.fftfreq(n, 1/fs)
    fft_signal = np.fft.fft(signal)

    # Calculamos el espectro de potencia
    power_spectrum = np.abs(fft_signal)**2

    # Filtramos las frecuencias negativas
    # Create a mask for positive frequencies with the original length
    mask = freqs > 0

    # Apply the mask to both frequencies and power spectrum
    freqs = freqs[mask]
    power_spectrum = power_spectrum[mask]

    # Encontramos la frecuencia de pico
    pkf = freqs[np.argmax(power_spectrum)]

    return pkf

# Calcular todas las m√©tricas

mnf, mdf = calculate_mnf_mdf(filtered_signal_1, fs)
pkf = calculate_pkf(filtered_signal_1, fs)

# Mostrar los resultados

print(f'MNF: {mnf} Hz')
print(f'MDF: {mdf} Hz')
print(f'Peak Frequency (PKF): {pkf} Hz')

metricas_df = pd.DataFrame(index=['filtered_signal_1', 'filtered_signal_2', 'filtered_signal_3'],
                          columns=['RMS', 'MAV', 'ARV', 'ZC', 'MNF', 'MDF', 'PKF'])

# Calcular m√©tricas para cada se√±al y guardar en el DataFrame
for i, signal in enumerate([filtered_signal_1, filtered_signal_2, filtered_signal_3]):
  metricas_df.loc[f'filtered_signal_{i+1}', 'RMS'] = calculate_rms(signal)
  metricas_df.loc[f'filtered_signal_{i+1}', 'MAV'] = calculate_mav(signal)
  metricas_df.loc[f'filtered_signal_{i+1}', 'ARV'] = calculate_arv(signal)
  metricas_df.loc[f'filtered_signal_{i+1}', 'ZC'] = calculate_zc(signal)
  metricas_df.loc[f'filtered_signal_{i+1}', 'MNF'], metricas_df.loc[f'filtered_signal_{i+1}', 'MDF'] = calculate_mnf_mdf(signal, fs)
  metricas_df.loc[f'filtered_signal_{i+1}', 'PKF'] = calculate_pkf(signal, fs)

# Mostrar el DataFrame
metricas_df

"""* MNF Es la frecuencia en la que se concentra el grueso de la energ√≠a espectral (ojo, es media ponderada). 1.28 indica que la frecuencia central de la se√±al EMG est√° muy baja, lo que generalmente est√° asociado con contracciones musculares lentas o de baja intensidad. En estos estados las unidades motoras de bajo umbral (que son m√°s lentas) est√°n activas y dominan la se√±al. Tambi√©n en caso de fatiga, el m√∫sculo comienza a reclutar unidades motoras de bajo umbral (m√∫sculos de contracci√≥n m√°s lenta) para mantener la actividad muscular, lo que provoca que la frecuencia de la se√±al EMG baje. A ritmo moderado nos metemos en 10 Hz y 20 Hz. Hasta 50 Hz ya estamos en modo HIT/sprint. Sensible a picos de energ√≠a.
* MDF es una frecuencia mediana en el espectro de la se√±al EMG que refleja la distribuci√≥n general de la energ√≠a en las frecuencias de la se√±al (se toma el peso de cada frecuencia seg√∫n su contribuci√≥n a la energ√≠a total y se calcula un promedio de esas frecuencias). Los rangos son tambi√©n menos de 10 Hz, entre 10 y 20 y m√°s de 20. 0.58 es muy bajo, significa lo mismo de antes. Menos sensible a picos y m√°s a las frecuencias dominantes.
* PKF es el punto donde el espectro de potencia alcanza su m√°ximo. Es particularmente √∫til en tareas de esfuerzo de corta duraci√≥n y alta intensidad, como movimientos explosivos, esfuerzos de potencia, o contracciones r√°pidas.  No est√° tan influenciado por las frecuencias bajas, sino que se concentra m√°s en picos espec√≠ficos, lo cual es muy √∫til para tareas que requieren detectar patrones espec√≠ficos de frecuencia.
"""

# Graficar las m√©tricas junto con la se√±al
plt.figure(figsize=(12, 6))

# Graficar se√±al filtrada
plt.subplot(2, 1, 1)
plt.plot(filtered_signal_2, label='Se√±al Filtrada')
plt.title("Se√±al Filtrada EMG")
plt.xlabel("Tiempo (muestras)")
plt.ylabel("Amplitud")

# Graficar espectro de frecuencias
plt.subplot(2, 1, 2)
n = len(filtered_signal_2)
frequencies = np.fft.fftfreq(n, 1/fs)
fft_vals = np.fft.fft(filtered_signal_2)
plt.plot(frequencies[:n//2], np.abs(fft_vals)[:n//2])
plt.title("Espectro de Frecuencia de la Se√±al")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Amplitud")

plt.tight_layout()
plt.show()

# Define la figura y los ejes en una matriz de 2x3
fig, axs = plt.subplots(2, 3, figsize=(18, 10))

# Lista de se√±ales filtradas
filtered_signals = [filtered_signal_1, filtered_signal_2, filtered_signal_3]

# Itera sobre las se√±ales para graficarlas y sus espectros
for i, signal in enumerate(filtered_signals):
    # Graficar la se√±al en la primera fila
    axs[0, i].plot(signal, label=f'Se√±al Filtrada {i+1}')
    axs[0, i].set_title(f"Se√±al Filtrada EMG {i+1}")
    axs[0, i].set_xlabel("Tiempo (muestras)")
    axs[0, i].set_ylabel("Amplitud")

    # Calcular y graficar el espectro de frecuencias en la segunda fila
    n = len(signal)
    frequencies = np.fft.fftfreq(n, 1/fs)
    fft_vals = np.fft.fft(signal)
    axs[1, i].plot(frequencies[:n//2], np.abs(fft_vals)[:n//2])
    axs[1, i].set_title(f"Espectro de Frecuencia {i+1}")
    axs[1, i].set_xlabel("Frecuencia (Hz)")
    axs[1, i].set_ylabel("Amplitud")
    # Set x-axis limits to 0-50 Hz
    axs[1, i].set_xlim(0, 5)

# Ajusta el espaciado entre los subplots y muestra la figura
plt.tight_layout()
plt.show()